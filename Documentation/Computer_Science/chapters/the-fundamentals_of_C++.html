<!DOCTYPE html>
<html>
   <head>
      <title> The Fundamentals of C++ </title>

      <meta name="description"
         content="The Fundamentals of C++"/>
      <meta name="robots"
         content="nofollow" />
      <meta http-equiv="author"
         content="Manuel Torres" />
      <meta http-equiv="pragma"
         content="no-cache"/>
      
      
      <link href="../../../css/body.css"
         type="text/css"
         rel="stylesheet"/>
   </head>
   <body class="lecture">
      <header>
         <div>
            <h1> The CS L@b </h1>
            <img src="../../../images/Artboard 1.png" />
         </div>       
         
         <nav>
            <ul class="v2">
               <li><a href="../../../portfolio/portfolio.html"> Portfolio </a></li>
               <li><a href="../../../index.html"> Home </a></li>
               <li><a href="../../documentation.html"> Documentation </a></li>
            </ul>
         </nav>
      </header>
      <div class="actual_body">
         <h1>The Fundamentals of C++</h1>
         <p>
            This lecture serves as an introduction to C++ and overall programming. It focuses on terminology, structure, and step by step instructions for C++ coding. The only prerequisites for this lecture are to have a working computer and a fundamental understanding of how to use it. The first section goes over the programming environment, explaining the applications and tools needed to write, compile, and run code. The next section will analyze basic code to understand its structure, keywords, and symbols. The final section goes into detail about the whole process, from preparing the proper tools to executing your first program. 
         </p>
         <h2>Knowing your Programming Environment</h2>
         <p>
            A programming environment is a set of tools that aids a developer in creating a operational program. The tools mentioned here are essential and will be explained in detail. They include a text editor, a terminal, compiler, and a debugger.  
         </p>
         <h3>The Text Editor</h3>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/Type_of_editors_on_windows.png" class="medium align_right" alt="" />
            Referring to the first tool, a <b>text editor</b> is an application that helps users write and edit text. Luckily, all operating systems (OS) come with one. For example, Windows OS has Notepad, MacOS has TextEdit, ChromeOS has Nano (more on that later), and the popular Ubuntu - one of the many distributors of Linux OS - has <i>Vim</i>. 
         </p>
         <p>
            For chromebook users, it is possible to install one via the Google Play Store, but it's recommended to enable the Linux environment and use their text editor. For chromebooks created during and after 2019, you can view the installation guide via the following <a href="https://support.google.com/chromebook/answer/9145439?hl=en" target="_blank" class="lecture">website</a>. Programmers are not limited to these four text editors. There are also open-source text editors that can come with extra features, such as <i>Microsoft's Visual Studio Code</i>. 
         </p>
         <p>
            For learning purposes and uniformity, this lecture and following lectures will use Vim. The reason for using Vim is because it's compatible with all operating systems, it's still relevant for today, and it's open-source software. Also, Vim is a program that comes integrated with every OS's terminal. The terminal is an important part of the programming environment that will be examined next. 
         </p>
         
         <h3>The Terminal</h3>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/PowerShell_LinuxTerm_cmd.png" class="medium align_left"/>
            The <b>terminal</b> is a text interface. It looks like a simple window with a couple of characters and a blinking cursor. All operating systems have a terminal. Unfortunately, the terminal by itself isn't useful, which is why there are shells. A <b>shell</b> is a program - also known as a <b>command-line interpreter</b> - that gives a user access to the operating system services by providing a list of commands the user can input in the terminal. There are many shells that can be used with the terminal. Some popular ones include <i>Bash</i>, <i>PowerShell</i>, and <i>Command Prompt (cmd)</i>. Caution, the shell isn't a visible application, it works in the background only giving hints of its existence through the terminal and its commands. Together, they allow users to access command-line applications (like Vim), manipulate files, install other tools, and other services a programmer needs.   
         </p>
         <p>   
            For learning purposes, this lecture and future lectures will use the terminal along with Bash. Both Linux OS and MacOS come with Bash shells in the terminal. Windows users need to take an extra step by installing <i>Windows Subsystem for Linux</i> (WSL) using the guide on the Microsoft <a href = "https://docs.microsoft.com/en-us/windows/wsl/install" target = "_blank" class = "lecture">website</a>. WSL creates a Linux environment on a Windows system, allowing user to execute Bash commands on the terminal and more. For those who don't want to install WSL, it is possible to use cmd and Notepad, but additional research is required. ChromeOS users have the terminal and Bash once they enable the Linux Environment. With the terminal and Bash, it is possible to write and store code. Though, to have the program run, the terminal needs to install a compiler. 
         </p>
         
         <h3>The Compiler</h3>
         <p>
            A <b>compiler</b> is software that translates a high-level language (like C++) into low a level language (such as assembly) for the system to understand. One of the most popular compilers is the GNU C++ Compiler - also known as g++ - and is what this lecture will use to help translate code. It is easy to install one within the terminal, and later sections will explain the installation process. It's great to finally have an executable file, but what if something goes wrong? Having a debugger can help reduce time in finding problems.
         </p>

         <h3>The Debugger</h3>
         <p>   
            Debuggers assist the programmer in finding problems within the code. For learning puposes we will use gdb which is the GNU Debugger that can be installed within the terminal as well. Later sections will show commands and how to install it. To some people, all these steps can be a hassle, fortunately there are applications that simplify this process, allowing them to code right away. 
         </p>
         
         <h3>Integrated Development Environment (IDE)</h3>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/Visual_Studio_pic.png" class="medium align_right"/> 
            <i>Integrated development environments</i> are applications that come with the same equipment that editors and terminals have, and then some. Warning, some of them state that they are free to use under certain conditions, like Microsoft's Visual Studio - not to get confused with Microsoft's Visual Studio Code which is just the editor. Basically, the software can only be for individual use, and programmers need to buy the business versions if they plan to work with groups. While text editors, terminals, and the tools used in these lectures are open source (FREE!). Companies like free, people like free, so it's best to follow the practices. Before writing any code, it is essential to understand what is written. 
         </p>

         <h2>The Basic Structure of Any Code</h2>
         <p>
            Here is a simple HelloWorld program which contains a couple lines of code. It provides the fundamental structure of how every C++ program is built. C++ is <i>case-sensitive</i>, for example, the keyword <code class="par">return</code> is different from the word Return. It also has a <i>free-form layout</i>, so space and line breaks are ignored during compilation. Caution, compiler doesn't ignore the content between line breaks and spaces. For example, "s t d" is interpreted as the letters s, t, and d while "std" is interpreted as the namespace called <code class="par">std</code> (more on that later). Still, a programmer can write each symbol, literal, identifier, and more on their own line, and it will still compile like the code below. To clarify, <i>literals</i> are the most fundamental values, like words or numbers. <i>Identifiers</i> are names that describe variables, functions, namespaces, objects, classes, and more; all of which will be discussed throughout the course. From here on, the lectures will use the Standard Library's files to create more complex code. Later sections will show how to install the Standard Library. For now, the following will explain each line in detail.
         </p>
         <code class="example" id="HelloWorld"> 
 1 //HelloWorld.cpp 
 2 #include &lt;iostream&gt;
 3 
 4 using namespace std;
 5 
 6 int main()
 7 {
 8   cout &lt;&lt; "Hello World!\n";
 9   return 0;
10 }

         </code>

         <h3>//HelloWorld.cpp</h3>
         <p>
            The first line is a comment describing the file's name. Comments are one or more lines of text ignored by the compiler. They are used for documentation purposes which help users understand the program. There are two types of comments a programmer can use: single-line comments and multi-line comments.
         </p>
         <code class="syntax">
// Single-line comment

/*
Multi-line comment
*/
         </code>
         <p>
            Single-line comments are denoted by the two forward slashes //. Anything after // that's on the same line is ignored by the compiler. The second type is the multi-line comment, and is denoted by /*...*/. Anything between the symbols /*...*/ are ignored by the compiler and can span multiple lines. 
         </p>

         <h3>#include &lt;iostream&gt;</h3>
         <p>
            On line 1, the <code class="par">#include</code> is a type of <i>preprocessing directive</i> which tells the compiler to look at and incorporate the contents of the <code class="par">iostream</code> <i>header file</i> before compiling HelloWorld.cpp. 
         </p>
         <p>   
            Preprocessing directives, in a general sense, provide rules for the compiler to follow before compiling the current source file. Later lectures will cover more preprocessing directives. Header files provide a list of identifiers for programmers to implement in their code. Future lectures will discuss string manipulation in more detail. Note, header files can either be user defined (within double quotations "") or part of a library (which are encapsulated in the &lt;...&gt; symbols). In this section we will identify the lines that use such tools from the <code class=par>iostream</code> header file. 
         </p>
         <p>
            More specifically, the header file <code class="par">iostream</code> is a type of file from the standard library. This file contains a list of input and output identifiers and operators that we can use. For now, keep in mind that iostream is just one of the many files existing in the standard library. Note, to use multiple header files in C++, each one needs a #include directives which can span multiple lines in the beginning of a program.   
         </p>
         <h3>using namespace std;</h3>
         <p>
            The statement on line 4 is a using-directive which allows the source file to use identifiers from the namespace called <code class="par">std</code>. The namespace called <code class="par">std</code> can be found within any of the header files in the standard library. An example can be seen by looking at the synopsis of <code class="par">iostream</code> on the cppreference <a href="https://en.cppreference.com/w/cpp/header/iostream" target="_blank" class="lecture">website</a>. In the synopsis there is a declaration of the namespace with the content between the {...}. The main purpose for a namespace is to avoid naming conflicts in the case where multiple identifiers have the same name, but different values. For studying purposes, this course will only use <code class="par">std</code> throughout. Besides namespaces, a statement is similar to a sentence, where the semicolon is like a period defining the end of a sentence. 
         </p>
         <h3>int main()</h3>
         <p>
            The 6th line creates function called main that should return an integer. Every program has a main function and can have additional functions. Each function carries out a process, which consist of code. The parentheses are where we can store parameters - additional information for the function to use - though since this is a simple program, it is left empty. Functions will be explained in future lectures. Finally, the identifier <code class="par">int</code> is called a data type. This specific data type says that the main function should return an integer.
         </p>
         <h3>{ ... }</h3>
         <p>
            The curly brackets and the content between lines 7 and 10 is considered a <i>block statement</i> and it defines the <b>scope</b> of the content within the main function. One of the main purposes of a scope is that its a preventative measure. It limits the readability of its content, only giving access when permited by the programmer. Anything outside the function's scope cannot use its content directly, and same applies to the function as it can't access anything outside its scope directly. However, nested scopes can access outer scopes. More will be explained as lectures show examples. 
         </p>
         <h3>cout &lt;&lt; "Hello World!\n";</h3>
         <p>
            Line 8 sends the content within "" - known as a <i>string</i> - to the terminal to be displayed, using the command <code class="par">cout &lt;&lt;</code>. More specically, a string is a combination of characters like symbols, letters, and <b>escape sequences</b>. Escape sequences are denoted by the backslash (\), and they tell the compiler to do certain tasks. For example, the <i>new line</i> escape sequence <code class="par">\n</code>, like the name suggests, tells the compiler to create a new line and start from there. Keep in mind that even though escape sequences are two character, the compiler sees it as one. More escape sequences will be touched upon in later lectures.
         </p>
         <p>
            To transfer this data to be visually displayed, the programmer uses the <b>insertion operator</b> <code class="par">&lt;&lt;</code>. The insertion operator inserts data in the order it was recieved to an output stream object to handle the rest. The operator is referenced in <i>&lt;iostream&gt;</i>. Keep in mind that it is an overloaded term, which will be discussed in the overloading lecture. 
         </p>
         <p>
            In this case, the output stream object that recieves the data is called <code class="par">cout</code>. This object controls output to a <b>stream buffer</b>. A stream buffer is another object, except this object performs all readding and writing to the terminal. Both the stream buffer and <code class="par">cout</code> are referenced in the iostream file.
         </p>
         <h3>return 0;</h3>
         <p>
            Remember how the main function expects an integer to be returned, well this is it. The compiler says to return 0. The digit 0 is considered a flag, it signals the compiler that there were no errors in the program, and that it can be terminated. However, if there are errors, the terminal will provide a long list of what seems like random words at first, but it is actually important information to fix the code.
         </p>
         <h2>Errors</h2>
         <p>
            There are two types of errors in programming, syntax errors and logical errors. A <b>syntax error</b> is a compilation error that detects missing symbols, values, and keywords from the program. An example would be a programmer forgetting to insert a semicolon at the end of a statement, or forgetting an operator. This is usually displayed in the terminal, stating the file and the location of the error. A <b>logical error</b> happens during the execution of the program and is only caught by the user. It can be anything from the code misbehaving and giving wrong values to not give values at all. Compilers can't find these errors, but a debugger can help find where the issue is at.
         </p>
         <h2>Preparing and Understanding the Terminal</h2>
         <p>
            Before using the terminal this section will go over fundamental commands. Afterwards, there will be step-by-step instructions for updating and installing tools. Finally, the lecture will end with a simple tutorial on how to run your first program. This section will try to anticipate any issues, but for further assistance please search online.
         </p>
         <h3>Commands</h3>
         <p>
            Commands for this instance will allow the user to traverse and manipulate the directory and files. Consider a directory as tree-like collection of files, where each directory branches to subdirectories (files within files), and where the root of the tree is usually the storage location.
         </p>

         <h4>pwd Command</h4>
         <code class="syntax"> 
$ pwd
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/pwd_cmd.png" class="small"/> <br /> 
            Provides a path to the currently accessed directory. A path consist of a root directory, and all subsequent directories separated by a forward slash (/). Note, in Windows OS each step of the path is separated by a backslash (\). Remember this when referring to Linux or Windows, since getting the two mixed up can cause errors. 
         </p>

         <h4>ls Command</h4>
         <code class="syntax">
$ ls
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/ls_cmd.png" class="small" /> <br />
            Provides a preview of the subdirectories in the current directory.
         </p>

         <h4>cd Command</h4>
         <code class="syntax">
$ cd directory_name 
$ cd .. 
$ cd 
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/cd_cmd.png" class="small" /> <br />
            Helps navigate the directory and can require additional input. For instance, to step into a subdirectory, type and enter the subdirectory's name after the cd command. To step back one directory, type two periods after the cd command. To step all the way back to the origin of the directory, enter cd by itself. Rather than using cd for every step, if the path of the desired directory is known, type the path after the command cd and then enter. Looking at the example, notice the path depicted in the green section, or notice the subdirectories when entering the command ls.
         </p>

         <h4>mkdir Command</h4>
         <code class="syntax">
$ mkdir directory_name
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/mkdir_cmd.png" class="small" /> <br />
            Create a subdirectory in the current directory.
         </p>

         <h4>vim Command</h4>
         <code class="syntax">
$ vim file_name.cpp
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/vim_cmd.png" class="small" /> <br />
            <img src="../../../images/C++/the_fundamentals_of_C++/cpp_file_instance.png" class="small align_right" />
            Creates and accesses the user defined C++ file. Note, these files have a (.cpp) extension which can be interpreted as “C Plus Plus”. Vim has modes and commands to edit, manipulate, save, and more. Typing right away will cause the first few characters from the keyboard to not register. To start writing/editing text, press the character (i) on the keyboard. This is known as insert mode and is shown at the bottom of the window. To quit any of the several modes, press the escape key. Deleting characters while not in insert mode will cause the cursor to move to the left instead of deleting the letters. To fix this, hit the (i) key again.
         </p>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/set_nmbr_cmd.png" class="small align_left"/>
            Vim has unique commands that can be entered in the command line, located at the bottom of the window. Before typing a command, exit out of any mode. Each command starts with a colon (:). <img src="../../../images/C++/the_fundamentals_of_C++/override.png" class="small align_right"/>
         </p>

         <h5>Help Command</h5>
         <code class="syntax">
:help
         </code>
         <p>
            This command provides a list of topic the user can traverse for more information. Fortunately, this lecture will go over a few of the basic commands. 
         </p>

         <h5>Set Number Command</h5>
         <code class="syntax">
:set number
         </code>
         <p>
            Provides line number to new or preexisting code. This makes it easier to distinguish where parts of the code are. 
         </p>

         <h5>Save Command</h5>
         <code class="syntax">
:w
         </code>
         <p>
            Saves the current state of the file. 
         </p>

         <h5>Quit Command</h5>
         <code class="syntax">
:q
         </code>
         <p>
            Quits Vim and goes back to the terminal without saving.
         </p>

         <h5>Force Quit Command</h5>
         <code class="syntax">
:q!
         </code>
         <p>
            Note, if a file has been edited and the quit command is executed before saving, Vim will warn the user about unsaved changes. To bypass this, enter the force quit command. Warning, anything that wasn't saved will be lost. 
         </p>
         
         <h5>Save Quit Command</h5>
         <code class="syntax">
:wq
         </code>
         <p>
            Instead of potentially loosing data, the better option is to use the save and quit command. This will save the file then exit out of Vim.
         </p>
         <p>   
            <img src="../../../images/C++/the_fundamentals_of_C++/saved_file.png" class="small align_left"/>
            Remember, Vim is an open-source editor. It comes with some distributors of Linux like Ubuntu, but if it's not installed, the terminal will complain and suggest installing it using whatever command it provides.
         </p> 

         <h4>gdb Command</h4>
         <code class="syntax">
$ gdb file_name
         </code>
         <p>
            Accesses the debugger for a file that was compiled with debugging in mind. Just like Vim, the debugger has its own set of commands.
         </p>
         <h5>run</h5>
         <code class="syntax">
(gdb) run para_1 ... para_n
         </code>
         <p>
            Runs program normally and can use additional arguments if needed.
         </p>

         <h5>b</h5>
         <code class="syntax">
(gdb) b param_1
         </code>
         <p>
            Sets a breakpoint by provideing: a function name, a line number, or a class member.
         </p>

         <h5>info b</h5>
         <code class="syntax">
(gdb) info b
         </code>
         <p>
            List all current breakpoints that are activated.
         </p>

         <h5>delete</h5>
         <code class="syntax">
(gdb) delete param_1 ... param_n
         </code>
         <p>
            Deletes the specified breakpoints
         </p>

         <h5>next</h5>
         <code class="syntax">
(gdb) next
         </code>
         <p>
            Executes the program one statement at a time, starting at the breakpoint. Useful to figure out on the surface level. 
         </p>

         <h5>step</h5>
         <code class="syntax">
(gdb) step
         </code>
         <p>
            If one statement references a process elsewhere, use this command to step into that process. Useful when program is trying to access another function or class elsewhere.
         </p>

         <h5>print</h5>
         <code class="syntax">
(gdb) print var_1 ... var_n
         </code>
         <p>
            prints the value that is specified. This value can be any variable that hold data.
         </p>

         <h5>where</h5>
         <code class="syntax">
(gdb) where
         </code>
         <p>
            Specifies information about the current location during debugging.  
         </p>

         <h5>frame</h5>
         <code class="syntax">
(gdb) frame
         </code>
         <p>
            Shows values of variables local to the calling function.
         </p>

         <h5>q</h5>
         <code class="syntax">
(gdb) q
         </code>
         <p>
            The command exits the debugger.
         </p>

         <p>
            These are just a few of the many commands the debugger uses, but they are essential.
         </p>

         <h4>rmdir Command</h4>
         <code class="syntax">
$ rmdir directory_name
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/rmdir_cmd.png" class="small" /> <br />
            Removes a subdirectory in the current directory. Warning, only removes empty directories.
         </p>

         <h4>rm Command</h4>
         <code class="syntax">
$ rm file_name
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/rm_cmd.png" class="small" /> <br />
            Removes files that are in the current directory.
         </p>

         <h4>sudo Command</h4>
         <code class="syntax">
$ sudo ...
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/sudo_cmd.png" class="small" /> <br />
            This command gives administrative access over operations. Any commands with sudo tagged onto it will initially ask for a password before doing its task, so make sure to remember the password. Knowing sudo, will allow users to update and install packages.
         </p>
         <h4>tmux</h4>
         <code class="syntax">
$ tmux
         </code>
         <p>
            Starts an environment where multiple terminals can run. To enter a tmux command first enter CTRL+b. Afterwards it will expect an order. For example, to split the terminal horizontally, enter SHIFT+5. To split the terminal vertically, enter SHIFT+'.To traverse any of the windows simply press any of the arrow keys. Keep in mind to enter CTRL+b every time before entering a tmux command. 
         </p>
         <p>
            To summarize, the following is a list of the commands that were reviewed during this lecture.
         </p>
         <table>
            <tr>
               <th>Commands</th>
               <th>Definitions</th>
            </tr>
            <tr>
               <td>pwd</td>
               <td>Provides a path to the currently accessed directory</td>
            </tr>
            <tr>
               <td>ls</td>
               <td>Provides a preview of the subdirectories in the current directory</td>
            </tr>
            <tr>
               <td>cd</td>
               <td>Helps navigate the directory and can require additional input</td>
            </tr>
            <tr>
               <td>mkdir</td>
               <td>Create a subdirectory in the current directory</td>
            </tr>
            <tr>
               <td>vim</td>
               <td>Creates and accesses the user defined C++ file</td>
            </tr>
            <tr>
               <td>gdb</td>
               <td>Accesses the debugger for a file that was compiled with debugging in mind</td>
            </tr>
            <tr>
               <td>rmdir</td>
               <td>Removes a subdirectory in the current directory</td>
            </tr>
            <tr>
               <td>rm</td>
               <td>Removes files that are in the current directory</td>
            </tr>
            <tr>
               <td>sudo</td>
               <td>Gives administrative access over operations</td>
            </tr>
            <tr>
               <td>tmux</td>
               <td>Starts an environment where multiple terminals can run</td>
            </tr>
         </table>


         <h3>Updating</h3>
         <p>
            To avoid issues when installing the compiler, check for updates. To do this, there are a set of instructions to follow.
         </p>
         <ol>
            <li>Updated package list.</li>
            <code class="par">$ sudo apt-get update</code>
            <ul>
               <li>The command is part of the Advanced Package Tool (APT) that helps get updates on the current packages.</li> 
               <li>Packages are just another way to say applications or software.</li>
            </ul>
            <li>Upgrade package list.</li>
            <code class="par">$ sudo apt-get upgrade</code>
            <li>Upgrade critical packages while cleaning up unnecessary packages.</li>
            <code class="par">$ sudo apt-get dist-upgrade</code>
         </ol>
         <p>
            If using sudo for the first time when starting up the system, it will require a password. Note, for chromeOS and Windows, the password is the one created when enabling Linux. For MacOS and Linux users, the password is just the regular one that is used to log into the PC. Also, enter the character (y) if it is asks for permission to upgrade. If successful, everything should be up to date. The next step is installing the compiler.
         </p>

         <h3>Installing Compiler and Debugger</h3>
         <p>
            There are two methods to download the package, but for this instance, use the build-essential route since it includes other key features like: libraries, debugger, and the compiler itself. To do this, type the following:
         </p>
         <code class="example">
$ sudo apt install build-essential
         </code>
         <p>
            Afterwards, check to see if it is installed by entering:
         </p>
         <code class="example">
$ g++ --version
         </code>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/gpp_version.png" class="medium" /> <br />
            If you see something like the image above, then the compiler has been successfully installed. Note, for more information on how to use g++ flags, enter the following command.
         </p>
         <code class="example">
$ g++ --help
         </code>
         <p>
            This will provide the basics information for flags used in the following section. Before going on to coding, first check if the gdb program is installed by entering the next command.
         </p>
         <code class="example">
$ gdb -help
         </code>
         <p>
            If successful, it will give a list of instructions, otherwise install gdb program by entering the following.
         </p>
         <code class="example">
$ sudo apt install gdb
         </code>
         <p>Once everything is installed, the next step is to write code.</p>

         <h2>Writing, Compiling, and Running Code</h2>
         <p>
            To begin: set up a user defined directory to store programs, in this case call it "Programs". 
         </p>
         <ol>
            <li>Make a specific directory for programs, in this case call it <i>Programs</i></li>
            <code class="par">$ mkdir Programs</code>
            <li>After creating a directory, access it with the cd command.</li>
            <code class="par">$ cd Programs</code>
            <li>Create and access a HelloWorld.cpp file using vim.</li>
            <code class="par">$ vim HelloWorld.cpp</code>
            <li>Write the <a href="#HelloWorld" class="lecture">example</a> from The Basic Structure of Code section into your code.</li>
            <ul>
               <li>Remember to enter the character (i) to begin typing</li>
               <li>When done hit the ESC key and enter the <code class="par">:wq</code> command to save and quit.</li>
            </ul>
            <li>Begin compiling using the following command.</li>
            <code class="par">g++ -c HelloWorld.cpp</code>
            <ul>
               <li>The flag -c compiles and assembles the program (.cpp) in an object file (.o).</li>
               <li>Remember, this file is considered a low level language that the computer can understand and run.
               </li>
               <li>At this point a syntax error may show instead of a file. The error's text in the terminal will identify the location of the error. Simply repeat steps 4-6.</li>
            </ul>
            <li>Examine the content of the folder to find an object file</li>
            <code class="par">ls</code>
            <ul>
               <li>Notice how it has the same name as the C++ file.</li>
            </ul>
            <li>Create executable file using the object file created.</li>
            <code class="par">$ g++ -o HelloWorld HelloWorld.cpp</code>
            <ul>
               <li>By default, the executable file has a (.out) extension, but it can't be seen if the name was user defined.</li>
            </ul>
            <li>Enter executable file using ./… to run it.</li>
            <code class="par">$ ./HelloWorld</code>
         </ol>
         <p>
            <img src="../../../images/C++/the_fundamentals_of_C++/output.png" class="small" /> <br />
            Once submitted, the output will be displayed on the next line in the terminal. If it runs and there are issues with the output, then it is considered a logical error. To fix this, we will use this opportunity to introduce the debugger. 
         </p>

         <h3>Debugging</h3>
         <p>
            The following is one of the many ways to aproach the issue.
         </p>
         <ol>
            <li>Enter <code class="par">tmux</code> to create a session to split terminal.</li>
            <li>Enter CTRL+B followed by either vertical split SHIFT+5 or horizontal split SHIFT+'.</li>
            <ul>
               <li>To traverse through either of the windows simply type CTRL+B followed by any directions from the arrow keys.</li>
            </ul>
            <li>On one window open up the program.</li>
            <li>On the other window compile the program, except use the -g flag instead.</li>
            <code class="par">g++ -c HelloWorld.cpp</code>
            <ul>
               <li>This will compile and create a generic executable file with C++ debugger in mind</li>
            </ul>
            <li>Enter the command to use the debugger with the executable file.</li>
            <code class="par">gdb a.out</code>
            <li>Create a break point at the beginning of the program, or at the area where the problem might be.</li>
            <li>Run the program so it stops at the breakpoint.</li>
            <li>Enter the command next to go through statement by statement.</li>
            <ul>
               <li>The program will display information like the current function name, the file's name, the output (if there is one), current line, and any syntax on that line</li>
            </ul>
            <li>Once the issue is found, fix it in the other window and compile the program again to run it normally.</li>
         </ol>

         <p>
            Keep in mind, it is possible to avoid using the -c and -o flag, but in some scenarios it is required to have a user defined name for the executable file. For future lecture, examples will be compiled using the -g flag to make life easier. Congratulations, you are officially a programmer! If you wish to continue, please read the next section.
         </p>
      </div>
   </body>
</html>
